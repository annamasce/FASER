  //////////////////////////////////////////////////////////
void FaserCalDisplay::LoadAllEvents()
{
  const std::string& folder_path = "input/";
  std::vector<std::string> file_paths;




  // Get all file paths in the input directory
  for (const auto& entry : std::filesystem::directory_iterator(folder_path))
    {
      file_paths.push_back(entry.path().string());
    }

  TDatabasePDG* pdgDB = TDatabasePDG::Instance();
  AddCustomNucleusParticles();
  
  // Loop over each file and extract information
  for (const std::string& file_path : file_paths)
    {
      std::cout << "Processing file: " << file_path << std::endl;
      
      // Extract the base name from the file path
      std::string base_name = std::filesystem::path(file_path).stem().string();
      std::cout << "basename " << base_name << std::endl;
      
      // Split the base_name using '_' as a delimiter
      std::istringstream ss(base_name);
      std::string token;
      std::vector<std::string> parts;
      while (std::getline(ss, token, '_'))
        {
	  parts.push_back(token);
        }
      
      if (parts.size() < 3)
        {
	  std::cerr << "Error: Invalid filename format, unable to parse: " << base_name << std::endl;
	  continue; // Skip this file if the format is incorrect
        }
      
      try {
	// Parse the event number, run number, and mask

	if()
	std::string event_number_str = parts[2];
	int ievent = std::stoi(event_number_str);
	std::string run_number_str = parts[1];
	int irun = std::stoi(run_number_str);
	std::string mask_str = parts[3];
	
	std::cout << "Event Number: " << ievent << ", Run Number: " << irun << ", Mask: " << mask_str << std::endl;
	int imask = 0;
	if (mask_str == "nueCC") imask = 1;
	else if (mask_str == "numuCC") imask = 2;
	else if (mask_str == "nutauCC") imask = 3;
	else if (mask_str == "nuNC") imask = 4;
	else if (mask_str == "nuES") imask = 5;
	
	fTcalEvent = new TcalEvent();
	POevent = new TPOEvent();
	fTcalEvent->Load_event("input/", irun, ievent, imask, POevent);
	
	// Initialize counters for each event
	int chargedMultiplicity = 0;
	int neutralMultiplicity = 0;
	int totalMultiplicity = 0;
	int gammaMultiplicity =0;
	int neutronMultiplicity =0;
	
	// Count the particles based on their properties
	for (size_t i = 0; i < POevent->n_particles(); i++)
	  {
	    struct PO& aPO = POevent->POs[i];
	    TParticlePDG* particle = pdgDB->GetParticle(aPO.m_pdg_id);
	    int charge = particle ? particle->Charge() : 0;
	    
	    if (aPO.m_status == 1)  // Only consider final state particles
	      {
		totalMultiplicity++;
		if (charge != 0) {
		  chargedMultiplicity++;
		} else {
		  neutralMultiplicity++;
		}
		if(aPO.m_pdg_id==22)
		  gammaMultiplicity++;
		if(aPO.m_pdg_id==2112)
		  neutronMultiplicity++;
	      }
	  }
	
	// Fill histograms based on mask type
	if (hMultiplicity.find(mask_str) != hMultiplicity.end()) {
	  hMultiplicity[mask_str]->Fill(totalMultiplicity);
	  hMultiplicityC[mask_str]->Fill(chargedMultiplicity);
	  hMultiplicity0[mask_str]->Fill(neutralMultiplicity);
	  hMultiplicityGm[mask_str]->Fill(gammaMultiplicity);
	  hMultiplicityN[mask_str]->Fill(neutronMultiplicity);
	  hNeutrinoEnergy[mask_str]->Fill(POevent->in_neutrino.m_energy);
	}
	
      } catch (const std::invalid_argument& e) {
	std::cerr << "Error: Invalid number format in filename: " << base_name << " - " << e.what() << std::endl;
      } catch (const std::out_of_range& e) {
	std::cerr << "Error: Number out of range in filename: " << base_name << " - " << e.what() << std::endl;
      }
    }
  
  // Calculate the maximum bin content separately for each mask type
  for (const auto& mask : masks) {
    double maxBinContent = 0.0;
    for (const auto& hist : {hMultiplicity[mask], hMultiplicityC[mask], hMultiplicity0[mask], hMultiplicityGm[mask], hMultiplicityN[mask]}) {
      if (hist->GetMaximum() > maxBinContent) {
	maxBinContent = hist->GetMaximum();
      }
    }
    // Set the maximum y-axis range for all histograms of the current mask type
    double yAxisMax = maxBinContent * 1.1; // Set slightly above the max for better visualization
    for (const auto& hist : {hMultiplicity[mask], hMultiplicityC[mask], hMultiplicity0[mask], hMultiplicityGm[mask], hMultiplicityN[mask]}) {
      hist->SetMaximum(yAxisMax);
      hist->SetStats(0);
    }
  }
  
  // Calculate the maximum bin content for Neutrino Energy histograms
  double maxBinContentNeutrinoEnergy = 0.0;
  for (const auto& mask : masks) {
    if (hNeutrinoEnergy[mask]->GetMaximum() > maxBinContentNeutrinoEnergy) {
      maxBinContentNeutrinoEnergy = hNeutrinoEnergy[mask]->GetMaximum();
    }
  }
  
  // Set the maximum y-axis range for Neutrino Energy histograms
  double yAxisMaxNeutrinoEnergy = maxBinContentNeutrinoEnergy * 1.1; // Set slightly above the max for better visualization
  for (const auto& mask : masks) {
    hNeutrinoEnergy[mask]->SetMaximum(yAxisMaxNeutrinoEnergy);
    hNeutrinoEnergy[mask]->SetStats(0);
  } 
  // Draw histograms for each mask type
  SetMyStyle();
  TCanvas *myCan = CreateCanvas("AllEvents", 1);
  gPad->Update();
  myCan->Divide(3, 2);  // 3 columns, 2 rows
  
  // Draw Multiplicity Histograms
  int pad = 1;
  for (const auto& mask : {"nueCC", "numuCC", "nutauCC", "nuNC", "nuES"}) {
    myCan->cd(pad++);
    hMultiplicity[mask]->SetLineColor(kBlack);
    hMultiplicityC[mask]->SetLineColor(kBlue);
    hMultiplicity0[mask]->SetLineColor(kRed);
    hMultiplicityN[mask]->SetLineColor(kGreen);
    hMultiplicityGm[mask]->SetLineColor(kOrange);
    
    hMultiplicity[mask]->Draw("hist");
    hMultiplicityC[mask]->Draw("hist same");
    hMultiplicityGm[mask]->Draw("hist same");
    hMultiplicityN[mask]->Draw("hist same");
    hMultiplicity0[mask]->Draw("hist same");

    TLegend *legend = new TLegend(0.65, 0.65, 0.84, 0.84);
    legend->AddEntry(hMultiplicity[mask], "Total", "l");
    legend->AddEntry(hMultiplicityC[mask], "Charged", "l");
    legend->AddEntry(hMultiplicity0[mask], "Neutral", "l");
    legend->AddEntry(hMultiplicityGm[mask], "Gamma", "l");
    legend->AddEntry(hMultiplicityN[mask], "Neutron", "l");
    legend->SetBorderSize(0);
    legend->SetFillColor(0);
    legend->Draw();
  }
  
  // Draw Neutrino Energy Histograms on a single canvas
  myCan->cd(pad++);
  int colorIndex = 2; // Starting color index
  for (const auto& mask : masks) {
    hNeutrinoEnergy[mask]->SetLineColor(colorIndex++);
    hNeutrinoEnergy[mask]->SetLineWidth(2);
    hNeutrinoEnergy[mask]->Draw(colorIndex == 3 ? "HIST" : "HIST SAME");
  }

  // Add a legend for Neutrino Energy histograms
  TLegend *legendEnergy = new TLegend(0.65, 0.65, 0.84, 0.84);
  legendEnergy->AddEntry(hNeutrinoEnergy["nueCC"], "nueCC", "l");
  legendEnergy->AddEntry(hNeutrinoEnergy["numuCC"], "numuCC", "l");
  legendEnergy->AddEntry(hNeutrinoEnergy["nutauCC"], "nutauCC", "l");
  legendEnergy->AddEntry(hNeutrinoEnergy["nuNC"], "nuNC", "l");
  legendEnergy->AddEntry(hNeutrinoEnergy["nuES"], "nuES", "l");
  legendEnergy->SetBorderSize(0);
  legendEnergy->SetFillColor(0);
  legendEnergy->Draw();
  
  gPad->Update();
  myCan->Update();
}
 