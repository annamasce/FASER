#include "FaserCalDisplay.h"
#include <iostream>
#include <algorithm>

#include <TEveWindow.h>
#include <TEveViewer.h>
#include <TSystem.h>
#include <TStyle.h>
#include <TGFrame.h>
#include <TGFont.h>
#include <TGLabel.h>
#include <TRootEmbeddedCanvas.h>
#include <TEveText.h>
#include <TEveTrans.h> 
#include <TGDMLParse.h>
#include <Form.h>

#include <TDatabasePDG.h>
#include <TParticlePDG.h>


namespace display
{
  FaserCalDisplay::FaserCalDisplay() {
    fNumberEntry = nullptr;
    fStatusBar = nullptr;
    fDetectorElements = new TEveElementList("Detector Elements");
    fHitElements = new TEveElementList("Hit Elements");
    fPrimaryElements = new TEveElementList("Primary Elements");  
    fSecondaryShowerElements = new TEveElementList("Secondary Shower Elements");  
    fSecondaryHadShowerElements = new TEveElementList("Secondary Hadron Shower Elements");  
    fPixelHitElements = new TEveElementList("Pixel Hit Elements");
    //fTcalEvent = nullptr;
    //POevent = nullptr;
    //fPORecoEvent = nullptr;
  }
  FaserCalDisplay::~FaserCalDisplay() {}
  
  void FaserCalDisplay::GetDetector()
  {
    std::cout << "Starting GetDetector()" << std::endl;
    // Load the GDML file using TGeoManager::Import
    TGeoManager::Import("/Users/ukose/WorkArea/FASER/Andre/FASER-1.0/GeomGDML/geometry.gdml");
    //
    if (!gGeoManager) {
      std::cerr << "Failed to import GDML file." << std::endl;
      return;
    }
    std::cout << "GDML file imported successfully." << std::endl;
    //
    TGeoVolume* gdmlTop = gGeoManager->GetTopVolume();
    if (!gdmlTop) {
      std::cerr << "Failed to get top volume." << std::endl;
      return;
    }
    //std::cout << "Top volume set: " << gdmlTop->GetName() << std::endl;
    TGeoIterator nextNode(gdmlTop);
    TGeoNode* curNode;
    //
    while ((curNode = nextNode())) {
      TGeoVolume* vol = curNode->GetVolume();
      if (!vol) {
	std::cerr << "Volume is null for node: " << curNode->GetName() << std::endl;
	continue;
      }
      //
      TGeoShape* shape = vol->GetShape();
      if (!shape) {
	std::cerr << "Shape is null for volume: " << vol->GetName() << std::endl;
	continue;
      }
      //
      TString nodeName(curNode->GetName());
      TString nodePath;
      nextNode.GetPath(nodePath);
      //std::cout << "Processing node: " << nodeName << ", path: " << nodePath << std::endl;
      // Get the transformation matrix of the current node
      const TGeoMatrix* matrix = nextNode.GetCurrentMatrix();
      if (!matrix) {
	std::cerr << "Matrix is null for node: " << curNode->GetName() << std::endl;
	continue;
      }
      //
      const Double_t* trans = matrix->GetTranslation();
      const Double_t* rotMatrix = matrix->GetRotationMatrix();
      if (!trans || !rotMatrix) {
	std::cerr << "Transformation matrix is null for node: " << curNode->GetName() << std::endl;
	continue;
      }
      //
      TGeoRotation rotation;
      rotation.SetMatrix(rotMatrix);
      TGeoCombiTrans transform(trans[0], trans[1], trans[2], &rotation);
      // Create the TEveGeoShape for visualization
      TEveGeoShape* eveShape = new TEveGeoShape(vol->GetName());
      eveShape->SetShape(shape);
      eveShape->SetMainTransparency(90); // Set transparency
      eveShape->SetTransMatrix(transform);
      //gEve->AddGlobalElement(eveShape);
      fDetectorElements->AddElement(eveShape);
    }
    gEve->AddGlobalElement(fDetectorElements);
    gEve->Redraw3D(kTRUE);
    std::cout << "GetDetector() completed." << std::endl;
  }
  void FaserCalDisplay::GetEventDisplay()
  {
    TEveManager* gEve = TEveManager::Create(kTRUE, "V");
    if (gROOT->IsBatch())
      gROOT->SetBatch(kFALSE);
    
    TEveRGBAPalette* pal = new TEveRGBAPalette(0, 1000);
    TEveViewer* ev = gEve->GetDefaultViewer();
    
    TEveWindowSlot* slot = TEveWindow::CreateWindowInTab(gEve->GetBrowser()->GetTabRight());
    TEveWindowPack* pack = slot->MakePack();
    pack->SetElementName("Multi View");
    pack->SetHorizontal();
    pack->SetShowTitleBar(kFALSE);
    
    pack->NewSlot()->MakeCurrent();
    TEveViewer* T3DView = gEve->SpawnNewViewer("Y-Z View", "");
    T3DView->GetGLViewer()->SetCurrentCamera(TGLViewer::kCameraOrthoZOY);
    T3DView->AddScene(gEve->GetGlobalScene());
    T3DView->AddScene(gEve->GetEventScene());
    
    pack = pack->NewSlot()->MakePack();
    pack->SetShowTitleBar(kFALSE);
    pack->NewSlot()->MakeCurrent();
    TEveViewer* TRPhiView = gEve->SpawnNewViewer("X-Y View", "");
    TRPhiView->GetGLViewer()->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
    TRPhiView->AddScene(gEve->GetGlobalScene());
    TRPhiView->AddScene(gEve->GetEventScene());

    pack->NewSlot()->MakeCurrent();
    TEveViewer* TRhoZView = gEve->SpawnNewViewer("X-Z View", "");
    TRhoZView->GetGLViewer()->SetCurrentCamera(TGLViewer::kCameraOrthoXOZ);
    TRhoZView->AddScene(gEve->GetGlobalScene());
    TRhoZView->AddScene(gEve->GetEventScene());

    TEveBrowser* browser = gEve->GetBrowser();
    browser->StartEmbedding(TRootBrowser::kLeft);

    TGMainFrame* frmMain = new TGMainFrame(gClient->GetRoot(), 1000, 600);
    frmMain->SetWindowName("XX GUI");
    frmMain->SetCleanup(kDeepCleanup);

    TGVerticalFrame* hf = new TGVerticalFrame(frmMain);
    TGGroupFrame* fGroupFrame2 = new TGGroupFrame(hf, "Event Display");
    fGroupFrame2->SetLayoutBroken(kTRUE);
    // Set Event Number Button
    int posy = 20;
    fNumberEntry = new TGNumberEntry(fGroupFrame2, 0, 6, -1, TGNumberFormat::kNESInteger, TGNumberFormat::kNEAAnyNumber, TGNumberFormat::kNELLimitMinMax, 0, 10000);
    fGroupFrame2->AddFrame(fNumberEntry, new TGLayoutHints(kLHintsLeft | kLHintsTop, 2, 2, 62, 2));
    fNumberEntry->MoveResize(20, posy, 90, 18);
    TGTextButton* b = new TGTextButton(fGroupFrame2, "Set Event#");
    b->Connect("Clicked()", "display::FaserCalDisplay", this, "SetEventNumber()");
    fGroupFrame2->AddFrame(b, new TGLayoutHints(kLHintsExpandX));
    b->MoveResize(120, posy, 90, 18);
    posy += 28;
    // Show Event Button
    TGTextButton* fb = new TGTextButton(fGroupFrame2, "ShowEvent");
    fb->Connect("Clicked()", "display::FaserCalDisplay", this, "ShowEvent()");
    fb->MoveResize(10, posy, 100, 18);
    fb->SetToolTipText("Show event");
    // Dump Event Button
    fb = new TGTextButton(fGroupFrame2, "DumpEvent");
    fb->Connect("Clicked()", "display::FaserCalDisplay", this, "DumpEvent()");
    fb->MoveResize(110, posy, 100, 18);
    fb->SetToolTipText("Dump event");

    posy += 25;
    // Next Event Button
    fb = new TGTextButton(fGroupFrame2, "Next");
    fb->Connect("Clicked()", "display::FaserCalDisplay", this, "NextEvent()");
    fb->MoveResize(10, posy, 100, 18);
    fb->SetToolTipText("Show next event");
    // Previous Event Button
    fb = new TGTextButton(fGroupFrame2, "Previous");
    fb->MoveResize(110, posy, 100, 18);
    fb->Connect("Clicked()", "display::FaserCalDisplay", this, "PreviousEvent()");
    fb->SetToolTipText("Show previous event");
    // Hide Detector Geometry
    posy += 25;
    fIsolate = new TGCheckButton(fGroupFrame2, "Hide Detector Geometry");
    fIsolate->MoveResize(10, posy, 0, 18);
    fIsolate->Connect("Clicked()", "display::FaserCalDisplay", this, "Isolate()");
    ////////////
    posy += 25;
    fPrimary = new TGCheckButton(fGroupFrame2, "Primary Particles");
    fPrimary->MoveResize(10, posy, 0, 18);
    fPrimary->Connect("Clicked()", "display::FaserCalDisplay", this, "ShowPrimary()");

    posy += 25;
    fEMShowers = new TGCheckButton(fGroupFrame2, "EM Showers");
    fEMShowers->MoveResize(10, posy, 0, 18);
    fEMShowers->Connect("Clicked()", "display::FaserCalDisplay", this, "ShowSecondaryShowers()");

    fHadronShowers = new TGCheckButton(fGroupFrame2, "Hadron Showers");
    fHadronShowers->MoveResize(110, posy, 0, 18);
    fHadronShowers->Connect("Clicked()", "display::FaserCalDisplay", this, "ShowSecondaryHadShowers()");

    posy += 25;
    fPixelTracker = new TGCheckButton(fGroupFrame2, "Pixel Tracker");
    fPixelTracker->MoveResize(10, posy, 0, 18);
    fPixelTracker->Connect("Clicked()", "display::FaserCalDisplay", this, "ShowPixelHits()");

    fZoom = new TGCheckButton(fGroupFrame2, "Zoom");
    fZoom->MoveResize(110, posy, 0, 18);
    fZoom->Connect("Clicked()", "display::FaserCalDisplay", this, "ZoomingEvent()");
    
    //fTPC = new TGCheckButton(fGroupFrame2, "TPC");
    //fTPC->MoveResize(110, posy, 0, 18);
    //fPandora = new TGCheckButton(fGroupFrame2, "Pandora");
    //fPandora->MoveResize(165, posy, 0, 18);

    //posy += 25;
    //TGLabel* labelc0 = new TGLabel(fGroupFrame2, "ADCcut");
    //labelc0->MoveResize(10, posy, 0, 18);
    //fRawDigitCut = new TGNumberEntry(fGroupFrame2, 0, 6, -1, TGNumberFormat::kNESInteger, TGNumberFormat::kNEAAnyNumber, TGNumberFormat::kNELLimitMinMax, 0, 100);
    //fRawDigitCut->MoveResize(70, posy, 0, 18);
    //fb = new TGTextButton(fGroupFrame2, "2D RawDigits");
    //fb->MoveResize(150, posy, 0, 18);
    //fb->SetToolTipText("Show 2D raw digits");

    hf->AddFrame(fGroupFrame2, new TGLayoutHints(kLHintsLeft | kLHintsTop, 2, 2, 2, 2));
    fGroupFrame2->MoveResize(0, 200, 240, 200);

    TGGroupFrame* fGroupFrame3 = new TGGroupFrame(hf, "Plots");
    fGroupFrame3->SetLayoutBroken(kTRUE);
    fb = new TGTextButton(fGroupFrame3, "MCTruth");
    fb->MoveResize(10, 20, 110, 18);
    fb = new TGTextButton(fGroupFrame3, "CRTPlots");
    fb->MoveResize(10, 40, 110, 18);
    fb->SetToolTipText("CRT plots");
    fb = new TGTextButton(fGroupFrame3, "LightPlots");
    fb->MoveResize(125, 20, 110, 18);
    fb = new TGTextButton(fGroupFrame3, "RawData");
    fb->MoveResize(125, 40, 110, 18);
    fb = new TGTextButton(fGroupFrame3, "SummaryTable");
    fb->MoveResize(10, 60, 110, 18);

    hf->AddFrame(fGroupFrame3, new TGLayoutHints(kLHintsLeft | kLHintsTop, 2, 2, 2, 2));
    fGroupFrame3->MoveResize(0, 210, 240, 100);

    TGGroupFrame* fGroupFrame4 = new TGGroupFrame(hf, "Animate");
    fGroupFrame4->SetLayoutBroken(kTRUE);
    posy = 20;
    int posx = 10;
    int dx = 20;

    fExt_b = new TGCheckButton(fGroupFrame4, "");
    fGroupFrame4->AddFrame(fExt_b, new TGLayoutHints(kLHintsLeft | kLHintsTop, 2, 2, 2, 2));
    fExt_b->MoveResize(10, posy, 110, 18);

    TGLabel* lTStep = new TGLabel(fGroupFrame4, "TSteps");
    lTStep->MoveResize(30, posy, 0, 18);

    fTSteps = new TGNumberEntry(fGroupFrame4, 50, 6, -1, TGNumberFormat::kNESInteger, TGNumberFormat::kNEAAnyNumber, TGNumberFormat::kNELLimitMinMax, 0, 10000);
    fTSteps->MoveResize(80, posy, 0, 18);

    fExt_l = new TGLabel(fGroupFrame4, " ns ");
    fExt_l->MoveResize(140, posy, 20, 18);
    fExt_NE = new TGNumberEntryField(fGroupFrame4, -1, 0, TGNumberFormat::kNESInteger);
    fExt_NE->MoveResize(155, posy, 75, 18);

    posy += 20;
    fHSlider_ext = new TGHSlider(fGroupFrame4, 220, kSlider1 | kScaleBoth, -1, kHorizontalFrame);
    fHSlider_ext->SetRange(0, 50);
    fHSlider_ext->SetPosition(0);
    fHSlider_ext->SetPosition(extPitch);
    fHSlider_ext->MoveResize(5, posy, 225, 15);
    fHSlider_ext->Connect("PositionChanged(Int_t)", "display::FaserCalDisplay", this, "DoSlider(Int_t)");

    hf->AddFrame(fGroupFrame4, new TGLayoutHints(kLHintsLeft | kLHintsTop, 2, 2, 2, 2));
    fGroupFrame4->MoveResize(0, 200, 240, 100);

    TGGroupFrame* fGroupFrame5 = new TGGroupFrame(hf, "WaveForms");
    fGroupFrame5->SetLayoutBroken(kTRUE);
    posx = 10;
    dx = 20;
    posy = 20;

    hf->AddFrame(fGroupFrame5, new TGLayoutHints(kLHintsLeft | kLHintsTop, 2, 2, 2, 2));
    fGroupFrame5->MoveResize(0, 210, 240, 100);

    TGGroupFrame* fGroupFrame6 = new TGGroupFrame(hf, "Saving");
    fGroupFrame6->SetLayoutBroken(kTRUE);
    posx = 10;
    dx = 20;
    posy = 20;

    eGCBAnimation = new TGCheckButton(fGroupFrame6, "Animation");
    eGCBAnimation->MoveResize(10, posy, 80, 20);
    fb = new TGTextButton(fGroupFrame6, "op");
    fb->MoveResize(90, posy, 20, 18);
    fb = new TGTextButton(fGroupFrame6, "Save animation");
    fb->MoveResize(125, posy, 100, 18);

    posy += 21;
    fb = new TGTextButton(fGroupFrame6, "Snapshot");
    fb->MoveResize(10, posy, 100, 18);
    fb = new TGTextButton(fGroupFrame6, "Save projections");
    fb->MoveResize(125, posy, 100, 18);
    // Change Background Color
    posy += 21;
    fb = new TGTextButton(fGroupFrame6, "ChangeBackgroundColour");
    fb->MoveResize(25, posy, 150, 20);
    fb->Connect("Clicked()", "display::FaserCalDisplay", this, "BackgroundColor()");
    // Exit Button
    posy += 21;
    fb = new TGTextButton(fGroupFrame6, "Exit");
    fb->MoveResize(55, posy, 100, 20);
    fb->Connect("Clicked()", "display::FaserCalDisplay", this, "DoExit()");

    hf->AddFrame(fGroupFrame6, new TGLayoutHints(kLHintsLeft | kLHintsTop, 2, 2, 2, 2));
    fGroupFrame6->MoveResize(0, 260, 240, 240);

    frmMain->AddFrame(hf);

    // status bar
    Int_t parts[] = {45,20,20,15};
    fStatusBar = gEve->GetBrowser()->GetStatusBar();
    fStatusBar->SetParts(parts,4);
    fStatusBar->SetText("Welcome to the FASERCal EventDisplay",0);


    
    frmMain->MapSubwindows();
    frmMain->Resize();
    frmMain->MapWindow();

    slot = TEveWindow::CreateWindowInTab(gEve->GetBrowser()->GetTabRight());
    fgHtml = new TGHtml(0, 100, 100);
    TEveWindowFrame* wf = slot->MakeFrame(fgHtml);
    fgHtml->MapSubwindows();
    wf->SetElementName("Summary");

    browser->StopEmbedding();
    browser->SetTabTitle("Main", 0);
    gEve->GetBrowser()->GetTabRight()->SetTab(1);

    gEve->Redraw3D(kTRUE);

    GetDetector();
    ShowAxis();

    
  }
  
  void FaserCalDisplay::ShowAxis()
  {
    TString axisName = "Coordinate system";
    Float_t axisArrowLength = 50.;
    Float_t axisArrowTubeR = 0.01;
    Color_t axisColor = kMagenta;
    Int_t axisLabelFontSize = 15;
    Int_t axisLabelOffset = 5;

    TEveElementList* axis = new TEveElementList(axisName, axisName);
    TEveArrow* xAxis = new TEveArrow(axisArrowLength, 0., 0.);
    xAxis->SetMainColor(axisColor);
    xAxis->SetTubeR(axisArrowTubeR);
    xAxis->SetConeR(axisArrowTubeR);
    xAxis->SetElementNameTitle("X Axis", "X");
    axis->AddElement(xAxis);
    TEveText* xAxisLabel = new TEveText("X");
    xAxisLabel->SetMainColor(axisColor);
    xAxisLabel->SetFontSize(axisLabelFontSize);
    xAxisLabel->SetLighting(kTRUE);
    Double_t trans[3];
    trans[0] = axisArrowLength + axisLabelOffset;
    trans[1] = 0;
    trans[2] = 0;
    xAxisLabel->PtrMainTrans()->SetPos(trans);
    axis->AddElement(xAxisLabel);

    TEveArrow* yAxis = new TEveArrow(0., axisArrowLength, 0.);
    yAxis->SetMainColor(axisColor);
    yAxis->SetTubeR(axisArrowTubeR);
    yAxis->SetConeR(axisArrowTubeR);
    yAxis->SetElementNameTitle("Y Axis", "Y");
    axis->AddElement(yAxis);
    TEveText* yAxisLabel = new TEveText("Y");
    yAxisLabel->SetMainColor(axisColor);
    yAxisLabel->SetFontSize(axisLabelFontSize);
    yAxisLabel->SetLighting(kTRUE);
    trans[0] = 0;
    trans[1] = axisArrowLength + axisLabelOffset;
    trans[2] = 0;
    yAxisLabel->PtrMainTrans()->SetPos(trans);
    axis->AddElement(yAxisLabel);

    TEveArrow* zAxis = new TEveArrow(0., 0., axisArrowLength);
    zAxis->SetMainColor(axisColor);
    zAxis->SetTubeR(axisArrowTubeR);
    zAxis->SetConeR(axisArrowTubeR);
    zAxis->SetElementNameTitle("Z Axis", "Z");
    axis->AddElement(zAxis);
    TEveText* zAxisLabel = new TEveText("Z");
    zAxisLabel->SetMainColor(axisColor);
    zAxisLabel->SetFontSize(axisLabelFontSize);
    zAxisLabel->SetLighting(kTRUE);
    trans[0] = 0;
    trans[1] = 0;
    trans[2] = axisArrowLength + axisLabelOffset;
    zAxisLabel->PtrMainTrans()->SetPos(trans);
    axis->AddElement(zAxisLabel);

    gEve->AddGlobalElement(axis);
    gEve->Redraw3D(kTRUE);

 
  }

  void FaserCalDisplay::BackgroundColor()
  {
    gEve->GetDefaultGLViewer()->SetClearColor(0);
    gEve->FullRedraw3D(kTRUE);
  }
  
  void FaserCalDisplay::DoExit()
  {
    std::cout << "Exit application..." << std::endl;
    gROOT->Reset();
    gApplication->Terminate(0);
  }
  
  void FaserCalDisplay::SetEventNumber()
  {
     if (!fNumberEntry) {
        std::cerr << "fNumberEntry is not initialized!" << std::endl;
        return;
    }
    fEventNumber = fNumberEntry->GetNumber();
    if (!fStatusBar) {
        std::cerr << "fStatusBar is not initialized!" << std::endl;
        return;
    }
    fStatusBar->GetBarPart(0)->SetBackgroundColor(0xffffff);
    fStatusBar->SetText(Form("   Showing Event#: %i   ", fEventNumber), 0);
    std::cout << "Event Number is " << fEventNumber << std::endl;
  }

 

  void FaserCalDisplay::Isolate()
  {
    if (!(fIsolate->IsOn())) {
      ApplyIsolation = kFALSE;
      //gEve->GetGlobalScene()->SetRnrSelf(kTRUE);
      fDetectorElements->SetRnrState(kTRUE);
      fHitElements->SetRnrSelf(kTRUE);  // Ensure hits are shown
      gStyle->SetPalette(-1);
      gEve->FullRedraw3D(kTRUE);
      std::cout << "Detector geometry will be shown" << std::endl;
    } else {
      ApplyIsolation = kTRUE;
      //gEve->GetGlobalScene()->SetRnrSelf(kFALSE);
      fDetectorElements->SetRnrState(kFALSE);
      fHitElements->SetRnrSelf(kTRUE);  // Ensure hits are shown
      gStyle->SetPalette(-1);
      gEve->FullRedraw3D(kTRUE);
      std::cout << "Detector geometry will be isolated" << std::endl;
    }
  }
  //////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////
  void FaserCalDisplay::ShowPrimary()
  { 
    if (fPrimary->IsOn())
    {
      std::cout << "Primary" << std::endl;
      fDetectorElements->SetRnrState(kFALSE);
      fHitElements->SetRnrState(kFALSE);
      fSecondaryShowerElements->SetRnrState(kFALSE);
      fSecondaryHadShowerElements->SetRnrState(kFALSE);
      fPixelHitElements->SetRnrState(kFALSE);  

      if(!fIsolate->IsOn())
	fDetectorElements->SetRnrState(kTRUE);
      else
	fDetectorElements->SetRnrState(kFALSE);
      gEve->AddGlobalElement(fPrimaryElements);
      fPrimaryElements->SetRnrState(kTRUE);  
      gStyle->SetPalette(-1);
      gEve->FullRedraw3D(kTRUE);
    } else {
      fHitElements->SetRnrState(kTRUE);
      gStyle->SetPalette(-1);
      gEve->FullRedraw3D(kTRUE);    
    }
  }
  //////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////
  void FaserCalDisplay::ShowSecondaryShowers()
  {
    if (fEMShowers->IsOn())
    {
      std::cout << "EM shower" << std::endl;
      fDetectorElements->SetRnrState(kFALSE);
      fHitElements->SetRnrState(kFALSE);
      fPrimaryElements->SetRnrState(kFALSE);  
      fSecondaryHadShowerElements->SetRnrState(kFALSE);
      fPixelHitElements->SetRnrState(kFALSE);  

      if(!fIsolate->IsOn())
	fDetectorElements->SetRnrState(kTRUE);
      else
	fDetectorElements->SetRnrState(kFALSE);

      gEve->AddGlobalElement(fSecondaryShowerElements);
      fSecondaryShowerElements->SetRnrState(kTRUE);  
      gStyle->SetPalette(-1);
      gEve->Redraw3D(kTRUE);
    } else {
      fHitElements->SetRnrState(kTRUE);
      gStyle->SetPalette(-1);
      gEve->FullRedraw3D(kTRUE);    
    }
  }
  void FaserCalDisplay::ShowSecondaryHadShowers()
  {    
    if (fHadronShowers->IsOn())
    {
      std::cout << "Had shower" << std::endl;
      fDetectorElements->SetRnrState(kFALSE);
      fHitElements->SetRnrState(kFALSE);
      fSecondaryShowerElements->SetRnrState(kFALSE);
      fPrimaryElements->SetRnrState(kFALSE);
      fPixelHitElements->SetRnrState(kFALSE);  

      if(!fIsolate->IsOn())
	fDetectorElements->SetRnrState(kTRUE);
      else
	fDetectorElements->SetRnrState(kFALSE);
 	
      gEve->AddGlobalElement(fSecondaryHadShowerElements);
      fSecondaryHadShowerElements->SetRnrState(kTRUE);  
      gStyle->SetPalette(-1);
      gEve->FullRedraw3D(kTRUE);      
    } else {
      fHitElements->SetRnrState(kTRUE);
      gStyle->SetPalette(-1);
      gEve->FullRedraw3D(kTRUE);    
    }
  }

 void FaserCalDisplay::ShowPixelHits()
  {    
    if (fPixelTracker->IsOn())
    {
      std::cout << "Hits on PixelTracker" << std::endl;
      fDetectorElements->SetRnrState(kFALSE);
      fHitElements->SetRnrState(kFALSE);
      fSecondaryShowerElements->SetRnrState(kFALSE);
      fPrimaryElements->SetRnrState(kFALSE);
      fSecondaryHadShowerElements->SetRnrState(kFALSE);  
      if(!fIsolate->IsOn())
	fDetectorElements->SetRnrState(kTRUE);
      else
	fDetectorElements->SetRnrState(kFALSE);
 	
      gEve->AddGlobalElement(fPixelHitElements);
      fPixelHitElements->SetRnrState(kTRUE);  
      gStyle->SetPalette(-1);
      gEve->FullRedraw3D(kTRUE);      
    } else {
      fHitElements->SetRnrState(kTRUE);
      gStyle->SetPalette(-1);
      gEve->FullRedraw3D(kTRUE);    
    }
  }
  
  void FaserCalDisplay::DoSlider(Int_t position)
  {
    fnumLayers = position;
    std::cout << "Slider position changed to: " << fnumLayers << " layers" << std::endl;
  }
  
  void FaserCalDisplay::CleanViewer()
  {
    gEve->GetViewers()->DeleteAnnotations();
    gEve->GetCurrentEvent()->DestroyElements();
    TEveElement* top = gEve->GetCurrentEvent();
    gEve->GetGlobalScene()->SetRnrSelf(kFALSE);
    TEveRGBAPalette* pal = new TEveRGBAPalette(0, 50);
    gGeoManager->GetTopVolume()->SetVisRaytrace(true);
    gEve->Redraw3D(kTRUE);
  }
  
  TCanvas* FaserCalDisplay::CreateCanvas(const char* plot_name, int tb)
  {
    TCanvas* myCan = (TCanvas*)gROOT->FindObject(plot_name);
    if (myCan) {
      myCan->Clear();
    } else {
      gEve->GetBrowser()->StartEmbedding(tb);
      gROOT->ProcessLineFast("new TCanvas");
      myCan = (TCanvas*)gPad;
      myCan->SetName(plot_name);
      gEve->GetBrowser()->StopEmbedding(plot_name);
    }
    return myCan;
  }
  
  void FaserCalDisplay::CleanCanvas()
  {
    TCanvas* myCan;
    myCan = (TCanvas*)gROOT->FindObject("RD_Cry0TPC0");
    if (myCan) myCan->Clear();
    myCan = (TCanvas*)gROOT->FindObject("RD_Cry0TPC1");
    if (myCan) myCan->Clear();
    myCan = (TCanvas*)gROOT->FindObject("RD_Cry1TPC0");
    if (myCan) myCan->Clear();
    myCan = (TCanvas*)gROOT->FindObject("RD_Cry1TPC1");
    if (myCan) myCan->Clear();
  }
  
  TCanvas* FaserCalDisplay::CreateTabs(const char* name)
  {
    TCanvas* cx = (TCanvas*)gROOT->FindObject(name);
    if (cx) return cx;
    
    gEve->GetBrowser()->StartEmbedding(1, -1);
    TGMainFrame* fMainTabFrame = new TGMainFrame(gClient->GetRoot(), 10, 10, kMainFrame | kVerticalFrame);
    fMainTabFrame->SetName(name);
    TGTab* fMainTab = new TGTab(fMainTabFrame, 300, 300);
    fMainTab->SetTab(1);
    fMainTab->Resize();
    fMainTabFrame->AddFrame(fMainTab, new TGLayoutHints(kLHintsLeft | kLHintsTop | kLHintsExpandX | kLHintsExpandY, 2, 2, 2, 2));
    
    fMainTabFrame->SetMWMHints(kMWMDecorAll, kMWMFuncAll, kMWMInputModeless);
    fMainTabFrame->MapSubwindows();
    fMainTabFrame->Resize();
    fMainTabFrame->MapWindow();
    gEve->GetBrowser()->StopEmbedding(name);
    
    TGCompositeFrame* subTabCompositeFrame = fMainTab->AddTab(name);
    subTabCompositeFrame->SetLayoutManager(new TGVerticalLayout(subTabCompositeFrame));
    TRootEmbeddedCanvas* rootEmbeddedCanvas = new TRootEmbeddedCanvas(0, subTabCompositeFrame, 300, 300);
    Int_t wfRootEmbeddedCanvas736a = rootEmbeddedCanvas->GetCanvasWindowId();
    cx = new TCanvas(name, 10, 10, wfRootEmbeddedCanvas736a);
    
    rootEmbeddedCanvas->AdoptCanvas(cx);
    subTabCompositeFrame->AddFrame(rootEmbeddedCanvas, new TGLayoutHints(kLHintsLeft | kLHintsTop | kLHintsExpandX | kLHintsExpandY, 2, 2, 2, 2));
    
    return cx;
  }
  
  void FaserCalDisplay::SetMyStyle()
  {
    Int_t myFont = 62;
    Double_t myWidth = 2;
    Double_t myTSize = 0.05;
    
    gROOT->SetStyle("Plain");
    TStyle* myStyle = new TStyle("myStyle", "FaserCalDisplay plots style");

    myStyle->SetFillColor(1);
    myStyle->SetFillStyle(1001);
    myStyle->SetFrameFillColor(0);
    myStyle->SetFrameBorderMode(0);
    myStyle->SetPadBorderMode(0);
    myStyle->SetPadColor(0);
    myStyle->SetCanvasBorderMode(0);
    myStyle->SetCanvasColor(0);
    myStyle->SetStatColor(0);
    myStyle->SetLegendBorderSize(0);
    myStyle->SetPalette(1);

    int colors[8] = {0, 5, 7, 3, 6, 2, 4, 1};
    myStyle->SetPalette(8, colors);

    myStyle->SetPaperSize(20, 26);
    myStyle->SetPadTopMargin(0.05);
    myStyle->SetPadRightMargin(0.05);
    myStyle->SetPadBottomMargin(0.16);
    myStyle->SetPadLeftMargin(0.14);

    myStyle->SetTextFont(myFont);
    myStyle->SetTextSize(myTSize);
    myStyle->SetLabelFont(myFont, "x");
    myStyle->SetLabelFont(myFont, "y");
    myStyle->SetLabelFont(myFont, "z");
    myStyle->SetLabelSize(myTSize, "x");
    myStyle->SetLabelSize(myTSize, "y");
    myStyle->SetLabelSize(myTSize, "z");
    myStyle->SetTitleFont(myFont);
    myStyle->SetTitleFontSize(0.3);
    myStyle->SetTitleFont(myFont, "x");
    myStyle->SetTitleFont(myFont, "y");
    myStyle->SetTitleFont(myFont, "z");
    myStyle->SetTitleSize(1.2 * myTSize, "x");
    myStyle->SetTitleSize(1.2 * myTSize, "y");
    myStyle->SetTitleSize(1.2 * myTSize, "z");

    myStyle->SetLineWidth(myWidth);
    myStyle->SetFrameLineWidth(myWidth);
    myStyle->SetHistLineWidth(myWidth);
    myStyle->SetFuncWidth(myWidth);
    myStyle->SetGridWidth(myWidth);
    myStyle->SetLineStyleString(2, "[12 12]");
    myStyle->SetMarkerStyle(20);
    myStyle->SetMarkerSize(1.0);

    myStyle->SetLabelOffset(0.010, "X");
    myStyle->SetLabelOffset(0.010, "Y");
    myStyle->SetTitleOffset(0.95, "X");
    myStyle->SetTitleOffset(0.95, "Y");
    myStyle->SetTitleOffset(1.2, "Z");
    myStyle->SetTitleFillColor(0);
    myStyle->SetTitleStyle(0);
    myStyle->SetTitleBorderSize(0);
    myStyle->SetTitleFont(myFont, "t");

    myStyle->SetOptStat(0);
    myStyle->SetOptFit(0);

    myStyle->SetStatBorderSize(0);
    myStyle->SetStatFont(myFont);
    myStyle->SetStatFontSize(0.05);
    myStyle->SetStatX(0.9);
    myStyle->SetStatY(0.9);
    myStyle->SetStatW(0.25);
    myStyle->SetStatH(0.15);

    myStyle->SetPadTickX(1);
    myStyle->SetPadTickY(1);
    gROOT->SetStyle("myStyle");
    gROOT->ForceStyle();
  }
  
  void FaserCalDisplayCamera::SetProjection()
  {
    TGButton* btn = (TGButton*)gTQSender;
    int id = btn->WidgetId();
    FaserCalDisplayCamera::SetCamera(id);
    std::cout << "ummmmmmmmmmmmm " << id << std::endl;
  }
  
  void FaserCalDisplayCamera::SetCamera(int projection)
  {
    TGTabElement* tab = gEve->GetBrowser()->GetTabRight()->GetCurrentTab();
    TEveViewerList* viewers = gEve->GetViewers();
    TGLViewer* eview = nullptr;
    for (TEveElement::List_i it = viewers->BeginChildren(); it != viewers->EndChildren(); it++) {
      if (strcmp(((TEveViewer*)(*it))->GetName(), tab->GetName()) == 0) {
	eview = ((TEveViewer*)(*it))->GetGLViewer();
	break;
      }
    }
    if (eview == nullptr) {
      eview = gEve->GetDefaultGLViewer();
    }
    switch (projection) {
    case X: {
      std::cout << "XPROJECTION" << std::endl;
      gEve->GetDefaultGLViewer()->SetCurrentCamera(TGLViewer::kCameraOrthoZOY);
      TGLOrthoCamera& cam = (TGLOrthoCamera&)(eview->CurrentCamera());
      cam.Reset();
      cam.RotateRad(-3.14159 * 0.5, 0.0);
      cam.SetEnableRotate(1);
    } break;
    }
  }

  //FaserCalData::FaserCalData(){};
  //FaserCalData::~FaserCalData(){};

  void FaserCalDisplay::AddCustomNucleusParticles()
  {
    struct CustomParticle {
      int pdgCode;
      const char* name;
      const char* title;
      double mass;
    };
    
    CustomParticle particles[] = {
        {1000050110, "B11", "Boron-11", 11.0093054},
        {1000060120, "C12", "Carbon-12", 12.0},
        {1000060130, "C13", "Carbon-13", 13.0033548378},
        {1000080160, "O16", "Oxygen-16", 15.99491461956},
        {1000080180, "O18", "Oxygen-18", 17.9991610},
        {1000110230, "Na23", "Sodium-23", 22.98976928},
        {1000120260, "Mg26", "Magnesium-26", 25.98259297},
        {1000130270, "Al27", "Aluminum-27", 26.9815385},
        {1000140280, "Si28", "Silicon-28", 27.97692653465},
        {1000140290, "Si29", "Silicon-29", 28.9764946653},
        {1000140300, "Si30", "Silicon-30", 29.973770136},
        {1000190390, "K39", "Potassium-39", 38.9637064864},
        {1000200400, "Ca40", "Calcium-40", 39.96259098},
        {1000200420, "Ca42", "Calcium-42", 41.95861801},
        {1000200430, "Ca43", "Calcium-43", 42.9587666},
        {1000200440, "Ca44", "Calcium-44", 43.9554818},
        {1000260540, "Fe54", "Iron-54", 53.9396105},
        {1000260560, "Fe56", "Iron-56", 55.9349375},
        {1000260570, "Fe57", "Iron-57", 56.9353940},
        {1000350810, "Br81", "Bromine-81", 80.9162906},
        {1000471070, "Ag107", "Silver-107", 106.9050916},
        {1000601420, "Nd142", "Neodymium-142", 141.9077233},
        {1000601430, "Nd143", "Neodymium-143", 142.9098143},
        {1000601440, "Nd144", "Neodymium-144", 143.9100873},
        {1000601450, "Nd145", "Neodymium-145", 144.9125736},
        {1000601460, "Nd146", "Neodymium-146", 145.9131169},
        {1000601480, "Nd148", "Neodymium-148", 147.9168930},
        {1000601500, "Nd150", "Neodymium-150", 149.920891},
        {1000741820, "W182", "Tungsten-182", 181.9482042},
        {1000741830, "W183", "Tungsten-183", 182.9502230},
        {1000741840, "W184", "Tungsten-184", 183.9509312},
        {1000741860, "W186", "Tungsten-186", 185.9543641},
        {1000822040, "Pb204", "Lead-204", 203.9730440},
        {1000822060, "Pb206", "Lead-206", 205.9744653},
        {1000822070, "Pb207", "Lead-207", 206.9758969},
        {1000822080, "Pb208", "Lead-208", 207.9766521}
    };

    TDatabasePDG* pdgDB = TDatabasePDG::Instance();

    for (const auto& particle : particles) {
        pdgDB->AddParticle(particle.name, particle.title, particle.mass, kFALSE, 0.0, 0, "Nucleus", particle.pdgCode);
    }

    std::cout << "Custom nucleus particles added to TDatabasePDG." << std::endl;
  }


  
  void FaserCalDisplay::DumpEvent()
  {
    std::cout << "Event to be dumped: " << fEventNumber << std::endl;
    //FaserCalData faserCalData;
    //faserCalData.LoadEvent(fEventNumber);
    LoadEvent(fEventNumber);
    TCanvas *myCan = CreateCanvas("EventInfo",1);
    gPad->Update();
    myCan->cd();
    TPaveText* infoText = new TPaveText(0.1, 0.1, 0.9, 0.9);
    infoText->AddText(Form("Run: %d Event: %d", POevent->run_number,fEventNumber));
    std::ostringstream eventtype;
    int pdgin = POevent->in_neutrino.m_pdg_id;
    switch(pdgin) {
      case -12:
      case 12:
        eventtype << "nu_e";
        break;
      case -14:
      case  14:
        eventtype << "nu_mu";
        break;
      case -16:
      case  16:
        eventtype << "nu_tau";
        break;
      default:
        eventtype << " ?? ";
    }
    if(POevent->isCC) {
      eventtype << " CC ";
    } else {
      eventtype << " NC ";
    }

    TDatabasePDG* pdgDB = TDatabasePDG::Instance();
    AddCustomNucleusParticles();
    int chargedMultiplicity = 0;
    int neutralMultiplicity = 0;
    int totalMultiplicity = 0;
    std::string target;
    for (size_t i=0; i<POevent->n_particles; i++) {
      struct PO& aPO = POevent->POs[i];
      TParticlePDG* particle = pdgDB->GetParticle(aPO.m_pdg_id);
      int charge = particle ? particle->Charge() : 0;
      if(aPO.m_status==1)
	{
	  totalMultiplicity++;
	  if (charge != 0) {
            chargedMultiplicity++;
	  } else {
            neutralMultiplicity++;
	  }
	}
        if(aPO.m_status==4)
	{
	  if(!POevent->is_neutrino(aPO.m_pdg_id))
	    {
	      target = particle ? particle->GetName() : "Unknown";
	      std::cout << "check target: "<< target << std::endl;
	      
	    }
	}
    }
    infoText->AddText(Form("Interaction: %s + %s ", eventtype.str().c_str(),target.c_str()));
    infoText->AddText(Form("Neutrino Energy: %.3f GeV",POevent->in_neutrino.m_energy));
    infoText->AddText(Form("Primary Vtx: %.3f %.3f %.3f",POevent->prim_vx[0],POevent->prim_vx[1],POevent->prim_vx[2]));
    infoText->AddText(Form("Multipcity: %d [Charged: %d Neutral: %d]",totalMultiplicity,chargedMultiplicity,neutralMultiplicity));
    if(POevent->isCC)
      {
	struct PO& outlepton = POevent->out_lepton;
	TParticlePDG* particle = pdgDB->GetParticle(outlepton.m_pdg_id);
	double plepton = TMath::Sqrt(outlepton.m_px*outlepton.m_px+outlepton.m_py*outlepton.m_py+outlepton.m_pz*outlepton.m_pz);
	infoText->AddText(Form("Lepton: %s P = %.1f GeV/c2 E= %.1f GeV",particle->GetName(),plepton,outlepton.m_energy));
      }
    infoText->AddText(Form("Number of segments: %lu", fTcalEvent->fTracks.size()));
    infoText->AddText(Form("----------------------------"));
    infoText->AddText(Form("Jet: %.3f %.3f %.3f", POevent->jetpx, POevent->jetpy, POevent->jetpz));
    infoText->AddText(Form("Sum final state: %.3f %.3f %.3f", POevent->spx, POevent->spy, POevent->spz));
    infoText->AddText(Form("Sum final state (Vis): %.3f %.3f %.3f", POevent->vis_spx, POevent->vis_spy, POevent->vis_spz));
    infoText->AddText(Form("Ptmiss: %.3f  Evis: %.3f ", POevent->ptmiss, POevent->Evis));


    infoText->Draw();
    gPad->Update();
    myCan->Update();
  }


  /*
  void FaserCalDisplay::DumpEvent()
  {
    std::cout << "Event to be dumped: " << fEventNumber << std::endl;
    LoadEvent(fEventNumber);
    TCanvas *myCan = CreateCanvas("Parameters",2);
    gPad->Update();
    myCan->cd();
    


    

    gPad->Update();
    myCan->Update();
  }
   
  */
  
  void FaserCalDisplay::ShowEvent()
  {
    std::cout << "Event to be shown " << fEventNumber << std::endl;
    DrawEvent(fEventNumber);
  }

  void FaserCalDisplay::NextEvent()
  {
    fCurrentEventNumber = fEventNumber;
    fEventNumber = fCurrentEventNumber + 1;
    std::cout << "Next Event Number is " << fEventNumber << std::endl;
    DrawEvent(fEventNumber);
    fStatusBar->GetBarPart(0)->SetBackgroundColor(0xffffff);
    fStatusBar->SetText(Form("   Showing Event#: %i   ", fEventNumber), 0);
  }

  void FaserCalDisplay::PreviousEvent()
  {
    fCurrentEventNumber = fEventNumber;
    fEventNumber = fCurrentEventNumber - 1;
    std::cout << "Previous Event Number is " << fEventNumber << std::endl;
    DrawEvent(fEventNumber);
    fStatusBar->GetBarPart(0)->SetBackgroundColor(0xffffff);
    fStatusBar->SetText(Form("   Showing Event#: %i   ", fEventNumber), 0);
  } 

  
  //void FaserCalData::LoadEvent(int ievent)
  void FaserCalDisplay::LoadEvent(int ievent)
  {
    std::string base_path = "input/tcalevent_";
    // Create an instance of TcalEvent and TPOEvent
    fTcalEvent = new TcalEvent();
    POevent = new TPOEvent();
    //
    fTcalEvent -> Load_event(base_path, ievent, POevent);
    std::cout << "Transverse size " << fTcalEvent->geom_detector.fScintillatorSizeX << " mm " << std::endl;
    std::cout << "Total size of one sandwich layer " << fTcalEvent->geom_detector.fSandwichLength << " mm " << std::endl;
    std::cout << "Number of layers " << fTcalEvent->geom_detector.NRep << std::endl;
    std::cout << "Voxel size " << fTcalEvent->geom_detector.fScintillatorVoxelSize << " mm " << std::endl;
    std::cout << " copied digitized tracks " << fTcalEvent->fTracks.size() << std::endl;
    fTcalEvent -> fTPOEvent -> dump_event();
    fPORecoEvent = new TPORecoEvent(fTcalEvent, fTcalEvent->fTPOEvent);
    fPORecoEvent -> Reconstruct();
    fPORecoEvent -> Dump();
  }

  void FaserCalDisplay::DrawEvent(int ievent)
  {

    if (!gEve) {
      std::cerr << "TEveManager is not initialized!" << std::endl;
      return;
    }
    
    TEveEventManager* currEvent = gEve->GetCurrentEvent();
    if( currEvent ) currEvent->DestroyElements();
    TEveElement* top = gEve->GetCurrentEvent();
    LoadEvent(ievent);
    
    double wdx, wdy, wdz;
    if (TGeoBBox *box = dynamic_cast<TGeoBBox*>(gGeoManager->GetTopVolume()->GetShape())){
	wdx = box->GetDX();
	wdy = box->GetDY();
	wdz = box->GetDZ()/2.0;
	printf("Top volume dimensions: DX = %f, DY = %f, DZ = %f\n", wdx, wdy, wdz);
      } else {
	std::cerr << "Failed to get top volume dimensions." << std::endl;
	exit(1);
      }
    TGeoShape *bigbox = new TGeoBBox("bigbox", wdx, wdy, wdz);
    TGeoMedium *air = gGeoManager->GetMedium("AIR");
    primary = new TGeoVolume("primary", bigbox, air);
    secondary_em = new TGeoVolume("secondary_em", bigbox, air);
    secondary_had = new TGeoVolume("secondary_had", bigbox, air);
    si_tracker = new TGeoVolume("si_tracker", bigbox, air);
    
    TGeoShape *box = new TGeoBBox("box", 0.5/2.0,0.5/2.0,0.5/2.0);
    TGeoShape *trackerhitbox = new TGeoBBox("box", 0.1/2.0,0.1/2.0,0.1/2.0);

    TGeoMaterial *matAluminum = new TGeoMaterial("Aluminum", 26.98, 13, 2.7);
    TGeoMedium *aluminum = new TGeoMedium("Aluminum", 2, matAluminum);
    
    std::cout << " using copied digitized tracks " << fTcalEvent->fTracks.size() << std::endl;

    TEveElementList* hitList = new TEveElementList("Hits");
    TEveElementList* primaryList = new TEveElementList("PrimaryHits");
    TEveElementList* secondaryShowerList = new TEveElementList("SecondaryShowerHits");
    TEveElementList* secondaryHadShowerList = new TEveElementList("SecondaryHadShowerHits");
    TEveElementList* pixelhitList = new TEveElementList("PixelHits");

    for (const auto& track : fTcalEvent->fTracks)
      {
	size_t nhits = track->fhitIDs.size();
	for ( size_t i = 0; i < nhits; i++)
	  {
	    long hittype = fTcalEvent->getChannelTypefromID(track->fhitIDs[i]);
	    
	    // apply energy cut on scintillator voxel
	    if(hittype == 0 && track->fEnergyDeposits[i] < 0.5)continue;
	    
	    ROOT::Math::XYZVector position = fTcalEvent->getChannelXYZfromID(track->fhitIDs[i]);
	    // Create a translation matrix for the hit position
	    TGeoTranslation *trans = new TGeoTranslation(position.X() / 10.0, position.Y() / 10.0, position.Z() / 10.0);

	    TGeoVolume* hitVolume = nullptr;
	    TGeoVolume *hitVolumeTracker = nullptr;
	    if(hittype == 0)
	      {
		hitVolume = new TGeoVolume("HitVolume", box, air);
		hitVolume->SetLineColor(kRed); 
		if(fabs(track->fPDG) == 11)
		  {
		    hitVolume->SetLineColor(kBlue); // electromagnetic is blue
		  }
		else if(fabs(track->fPDG) == 13)
		  {
		    hitVolume->SetLineColor(kGreen); // muons
		  }
		// get primary tracks
		if(track->fparentID == 0)
		  {
		    primary->AddNode(hitVolume, i, trans);
		  }
		else
		  {
		    if(fabs(track->fPDG) == 11)
		      {
			secondary_em->AddNode(hitVolume, i, trans);
		      }
		    else
		      {
			secondary_had->AddNode(hitVolume, i, trans);
		      }
		  }
	      }
	    else if (hittype == 1)
	      {
		hitVolumeTracker = new TGeoVolume("TrackerHitVolume", trackerhitbox, air);
		hitVolumeTracker->SetLineColor(kMagenta); 
		si_tracker->AddNode(hitVolumeTracker, i, trans);
	      }
	    else
	      {
		std::cout << " Unknown type of hit " << std::endl;
	      }
            if (hitVolume)
	      {
                TEveGeoShape* eveShape = new TEveGeoShape(hitVolume->GetName());
                eveShape->SetShape(hitVolume->GetShape());
                eveShape->SetMainColor(hitVolume->GetLineColor());
                eveShape->SetTransMatrix(*trans);
                hitList->AddElement(eveShape);
	      }
            if (hitVolumeTracker)
	      {
                TEveGeoShape* eveShapeP = new TEveGeoShape(hitVolumeTracker->GetName());
                eveShapeP->SetShape(hitVolumeTracker->GetShape());
                eveShapeP->SetMainColor(hitVolumeTracker->GetLineColor());
                eveShapeP->SetTransMatrix(*trans);
                pixelhitList->AddElement(eveShapeP);
	      }
	  }
      }
    if (primary) {
      std::cout << "...... " << primary->GetNdaughters() << std::endl;
      for (int i = 0; i < primary->GetNdaughters(); ++i) {
	TGeoNode* node = primary->GetNode(i);
	if (!node) continue;  
	TGeoVolume* vol = node->GetVolume();
	TGeoTranslation* trans = dynamic_cast<TGeoTranslation*>(node->GetMatrix());
	if (vol && trans) {
	  TEveGeoShape* eveShape = new TEveGeoShape(vol->GetName());
	  eveShape->SetShape(vol->GetShape());
	  eveShape->SetMainColor(vol->GetLineColor());
	  eveShape->SetTransMatrix(*trans);
	  primaryList->AddElement(eveShape);
	}
      }
      fPrimaryElements->AddElement(primaryList);
    }
    if (secondary_em) {
      std::cout << "...... " << secondary_em->GetNdaughters() << std::endl;
      for (int i = 0; i < secondary_em->GetNdaughters(); ++i) {
	TGeoNode* node = secondary_em->GetNode(i);
	if (!node) continue;  
	TGeoVolume* vol = node->GetVolume();
	TGeoTranslation* trans = dynamic_cast<TGeoTranslation*>(node->GetMatrix());
	if (vol && trans) {
	  TEveGeoShape* eveShape = new TEveGeoShape(vol->GetName());
	  eveShape->SetShape(vol->GetShape());
	  eveShape->SetMainColor(vol->GetLineColor());
	  eveShape->SetTransMatrix(*trans);
	  secondaryShowerList->AddElement(eveShape);
	}
      }
      fSecondaryShowerElements->AddElement(secondaryShowerList);
    }
    if (secondary_had) {
      std::cout << "...... " << secondary_had->GetNdaughters() << std::endl;
      for (int i = 0; i < secondary_had->GetNdaughters(); ++i) {
	TGeoNode* node = secondary_had->GetNode(i);
	if (!node) continue;  
	TGeoVolume* vol = node->GetVolume();
	TGeoTranslation* trans = dynamic_cast<TGeoTranslation*>(node->GetMatrix());
	if (vol && trans) {
	  TEveGeoShape* eveShape = new TEveGeoShape(vol->GetName());
	  eveShape->SetShape(vol->GetShape());
	  eveShape->SetMainColor(vol->GetLineColor());
	  eveShape->SetTransMatrix(*trans);
	  secondaryHadShowerList->AddElement(eveShape);
	}
      }
      fSecondaryHadShowerElements->AddElement(secondaryHadShowerList);
    }

    if (si_tracker) {
      std::cout << "...xx... " << si_tracker->GetNdaughters() << std::endl;
      for (int i = 0; i < si_tracker->GetNdaughters(); ++i) {
	TGeoNode* node = si_tracker->GetNode(i);
	if (!node) continue;
	//std::cout<< "here i am!! " << std::endl;
	TGeoVolume* vol = node->GetVolume();
	TGeoTranslation* trans = dynamic_cast<TGeoTranslation*>(node->GetMatrix());
	if (vol && trans) {
	  TEveGeoShape* eveShape = new TEveGeoShape(vol->GetName());
	  eveShape->SetShape(vol->GetShape());
	  eveShape->SetMainColor(vol->GetLineColor());
	  eveShape->SetTransMatrix(*trans);
	  pixelhitList->AddElement(eveShape);
	}
      }
      fPixelHitElements->AddElement(pixelhitList);
    }
    
    fHitElements->AddElement(hitList);
    gEve->AddGlobalElement(fHitElements);
    gEve->FullRedraw3D(kTRUE);
  }
  
  ///////////////////////
  void FaserCalDisplay::ZoomEvent(int ievent)
  {
    if (!gEve) {
      std::cerr << "TEveManager is not initialized!" << std::endl;
      return;
    }
    
    TEveEventManager* currEvent = gEve->GetCurrentEvent();
    if (currEvent) currEvent->DestroyElements();
    TEveElement* top = gEve->GetCurrentEvent();
    LoadEvent(ievent);

    double wdx, wdy, wdz;
    if (TGeoBBox *box = dynamic_cast<TGeoBBox*>(gGeoManager->GetTopVolume()->GetShape())) {
      wdx = box->GetDX();
      wdy = box->GetDY();
      wdz = box->GetDZ() / 2.0;
      printf("Top volume dimensions: DX = %f, DY = %f, DZ = %f\n", wdx, wdy, wdz);
    } else {
      std::cerr << "Failed to get top volume dimensions." << std::endl;
      exit(1);
    }
    TGeoShape *bigbox = new TGeoBBox("bigbox", wdx, wdy, wdz);
    TGeoMedium *air = gGeoManager->GetMedium("AIR");
    primary = new TGeoVolume("primary", bigbox, air);
    secondary_em = new TGeoVolume("secondary_em", bigbox, air);
    secondary_had = new TGeoVolume("secondary_had", bigbox, air);
    si_tracker = new TGeoVolume("si_tracker", bigbox, air);

    TGeoShape *box = new TGeoBBox("box", 0.5 / 2.0, 0.5 / 2.0, 0.5 / 2.0);
    TGeoShape *trackerhitbox = new TGeoBBox("box", 0.1 / 2.0, 0.1 / 2.0, 0.1 / 2.0);
    
    TGeoMaterial *matAluminum = new TGeoMaterial("Aluminum", 26.98, 13, 2.7);
    TGeoMedium *aluminum = new TGeoMedium("Aluminum", 2, matAluminum);
    
    std::cout << "Using copied digitized tracks " << fTcalEvent->fTracks.size() << std::endl;
    
    TEveElementList* hitList = new TEveElementList("Hits");
    TEveElementList* primaryList = new TEveElementList("PrimaryHits");
    TEveElementList* secondaryShowerList = new TEveElementList("SecondaryShowerHits");
    TEveElementList* secondaryHadShowerList = new TEveElementList("SecondaryHadShowerHits");
    TEveElementList* pixelhitList = new TEveElementList("PixelHits");
    
    ROOT::Math::XYZVector primaryVertex(POevent->prim_vx[0], POevent->prim_vx[1], POevent->prim_vx[2]);
    double layerThickness = fTcalEvent->geom_detector.fSandwichLength; // Length of one sandwich layer
    
    for (const auto& track : fTcalEvent->fTracks) {
      size_t nhits = track->fhitIDs.size();
      for (size_t i = 0; i < nhits; i++) {
	long hittype = fTcalEvent->getChannelTypefromID(track->fhitIDs[i]);
        
	// apply energy cut on scintillator voxel
	if (hittype == 0 && track->fEnergyDeposits[i] < 0.5) continue;
	
	ROOT::Math::XYZVector position = fTcalEvent->getChannelXYZfromID(track->fhitIDs[i]);
	
	// Filter hits based on the number of layers
	if (fZoom) {
	  double distance = abs(position.Z() - primaryVertex.Z());
	  
	  if (distance > fnumLayers*layerThickness) {
	    continue;
	  }
	  // Create a translation matrix for the hit position
	  TGeoTranslation *trans = new TGeoTranslation(position.X() / 10.0, position.Y() / 10.0, position.Z() / 10.0);
	  
	  TGeoVolume* hitVolume = nullptr;
	  TGeoVolume *hitVolumeTracker = nullptr;
	  if (hittype == 0) {
	    hitVolume = new TGeoVolume("HitVolume", box, air);
	    hitVolume->SetLineColor(kRed);
	    if (fabs(track->fPDG) == 11) {
	      hitVolume->SetLineColor(kBlue); // electromagnetic is blue
	    } else if (fabs(track->fPDG) == 13) {
	      hitVolume->SetLineColor(kGreen); // muons
	    }
	    // get primary tracks
	    if (track->fparentID == 0) {
	      primary->AddNode(hitVolume, i, trans);
	    } else {
	      if (fabs(track->fPDG) == 11) {
		secondary_em->AddNode(hitVolume, i, trans);
	      } else {
		secondary_had->AddNode(hitVolume, i, trans);
	      }
	    }
	  } else if (hittype == 1) {
	    hitVolumeTracker = new TGeoVolume("TrackerHitVolume", trackerhitbox, air);
	    hitVolumeTracker->SetLineColor(kBlack);
	    si_tracker->AddNode(hitVolumeTracker, i, trans);
	  } else {
	    std::cout << "Unknown type of hit" << std::endl;
	  }
	  if (hitVolume) {
	    TEveGeoShape* eveShape = new TEveGeoShape(hitVolume->GetName());
	    eveShape->SetShape(hitVolume->GetShape());
	    eveShape->SetMainColor(hitVolume->GetLineColor());
	    eveShape->SetTransMatrix(*trans);
	    hitList->AddElement(eveShape);
	  }
	}
      }
    }//
    
    
    if (primary) {
      std::cout << "...... " << primary->GetNdaughters() << std::endl;
      for (int i = 0; i < primary->GetNdaughters(); ++i) {
	TGeoNode* node = primary->GetNode(i);
	if (!node) continue;
	TGeoVolume* vol = node->GetVolume();
	TGeoTranslation* trans = dynamic_cast<TGeoTranslation*>(node->GetMatrix());
	if (vol && trans) {
	  TEveGeoShape* eveShape = new TEveGeoShape(vol->GetName());
	  eveShape->SetShape(vol->GetShape());
	  eveShape->SetMainColor(vol->GetLineColor());
	  eveShape->SetTransMatrix(*trans);
	  primaryList->AddElement(eveShape);
	}
      }
      fPrimaryElements->AddElement(primaryList);
    }
    if (secondary_em) {
      std::cout << "...... " << secondary_em->GetNdaughters() << std::endl;
      for (int i = 0; i < secondary_em->GetNdaughters(); ++i) {
	TGeoNode* node = secondary_em->GetNode(i);
	if (!node) continue;
	TGeoVolume* vol = node->GetVolume();
	TGeoTranslation* trans = dynamic_cast<TGeoTranslation*>(node->GetMatrix());
	if (vol && trans) {
	  TEveGeoShape* eveShape = new TEveGeoShape(vol->GetName());
	  eveShape->SetShape(vol->GetShape());
	  eveShape->SetMainColor(vol->GetLineColor());
	  eveShape->SetTransMatrix(*trans);
	  secondaryShowerList->AddElement(eveShape);
	}
      }
      fSecondaryShowerElements->AddElement(secondaryShowerList);
    }
    if (secondary_had) {
      std::cout << "...... " << secondary_had->GetNdaughters() << std::endl;
      for (int i = 0; i < secondary_had->GetNdaughters(); ++i) {
	TGeoNode* node = secondary_had->GetNode(i);
	if (!node) continue;
	TGeoVolume* vol = node->GetVolume();
	TGeoTranslation* trans = dynamic_cast<TGeoTranslation*>(node->GetMatrix());
	if (vol && trans) {
	  TEveGeoShape* eveShape = new TEveGeoShape(vol->GetName());
	  eveShape->SetShape(vol->GetShape());
	  eveShape->SetMainColor(vol->GetLineColor());
	  eveShape->SetTransMatrix(*trans);
	  secondaryHadShowerList->AddElement(eveShape);
	}
      }
      fSecondaryHadShowerElements->AddElement(secondaryHadShowerList);
    }
    
    if (si_tracker) {
      std::cout << "...xx... " << si_tracker->GetNdaughters() << std::endl;
      for (int i = 0; i < si_tracker->GetNdaughters(); ++i) {
	TGeoNode* node = si_tracker->GetNode(i);
	if (!node) continue;
	TGeoVolume* vol = node->GetVolume();
	TGeoTranslation* trans = dynamic_cast<TGeoTranslation*>(node->GetMatrix());
	if (vol && trans) {
	  TEveGeoShape* eveShape = new TEveGeoShape(vol->GetName());
	  eveShape->SetShape(vol->GetShape());
	  eveShape->SetMainColor(vol->GetLineColor());
	  eveShape->SetTransMatrix(*trans);
	  pixelhitList->AddElement(eveShape);
	}
      }
      fPixelHitElements->AddElement(pixelhitList);
    }
    
    fHitElements->AddElement(hitList);
    gEve->AddGlobalElement(fHitElements);
    gEve->FullRedraw3D(kTRUE);
  }
  


  
}  // namespace display
